<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[如何超过大多数人]]></title>
    <url>%2F2019%2F08%2F16%2F%E5%A6%82%E4%BD%95%E8%B6%85%E8%BF%87%E5%A4%A7%E5%A4%9A%E6%95%B0%E4%BA%BA%2F</url>
    <content type="text"><![CDATA[陈皓写的一篇文章，个人觉得很有价值。他谈到中国当下互联网存在的各种的问题，分析的透彻: 中国的互联网，它具有及其的诱导性，越使用它，并且你没有能力取甄别的时候，你会彻底丧失人的思考能力，彻底的废掉.]]></content>
  </entry>
  <entry>
    <title><![CDATA[排序算法]]></title>
    <url>%2F2019%2F08%2F09%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1.冒泡排序1234567891011121314void BubbleSort(vector&lt;int&gt;&amp; arr)&#123; if( arr.size() &lt; 2 ) return; for( int i = arr.sizr() - 1; i &gt; 0; --i )&#123; int flag = 0; for( int j = 0; j &lt; i ;++j ) if( arr[j] &gt; arr[j+1] )&#123; swap( arr[j],arr[j+1] ); flag = 1; &#125;// if if( flag == 0 ) return; &#125;// for-out&#125; 2.选择排序12345678910void SelectSort( vector&lt;int&gt;&amp; arr )&#123; if( arr.size() ) return; for( int i = 0; i &lt; arr.size() - 1; ++i )&#123; int minIndex = i; for( int j = i+1; j &lt; arr.size();j++ ) minIndex = arr[j] &lt; arr[minIndex] ? j : minIndex; swap( arr[i], arr[minIndex] ); &#125;&#125; 3.插入排序12345678void InsertSort( vector&lt;int&gt;&amp; arr )&#123; if( arr.size() &lt; 2 ) return; for( int i = 1; i &lt; arr.size(); ++i ) for( int j = i; j&gt;0; --j ) if( arr[j] &gt; arr[j - 1] ) swap( arr[j], arr[j-1] );&#125; 4.归并排序123456789101112131415161718192021222324252627282930313233343536/* * @Author wuhan * @Description * @Date * @Param 此数组[L,mid]与[mid+1,R]已经有序,合并他们成为[L,R]的有序数组 * @return **/void Merge( vector&lt;int&gt;&amp; arr, int L, int mid, int R )&#123; int* temp = new int[R-L+1]; int index = 0; int p1 = L; int p2 = mid + 1; while( p1 &lt;= mid &amp;&amp; p2 &lt;= R ) temp[index++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++]; while( p1 &lt;= mid ) temp[index++] = arr[p1++]; while( p2 &lt;= R ) temp[index++] = arr[p2++]; for( int i = 0; i &lt; R-L+1; ++i ) arr[L+i] = temp[i];&#125;/* * @Author wuhan * @Description * @Date * @Param 排序好[L,R]的位置, 比如[1,10]的位置 * @return **/void MergeSort( vector&lt;int&gt;&amp; arr, int L, int R )&#123; if( L == R ) return; int mid = L + ((R -L) &gt;&gt; 1); MergeSort( arr, L, mid ); MergeSort( arr, mid+1, R ); MergeSort( arr, L, mid, R );&#125; 5.快速排序12345678910111213141516171819202122232425262728293031323334353637/* * @Author wuhan * @Description * @Date * @Param 最后切分得到的数组partion中[n,m], [2,1,5,3,6,6,6,8,7,10],则n = 4, m =6 * @return **/void Partion( vector&lt;int&gt;&amp; arr, int l, int r, int partion[] )&#123; int less = l - 1; int more = r; while( l &lt; more ) if( arr[l] &lt; arr[r] ) swap(arr[++less], arr[l++]); else if( arr[l] &gt; arr[r] ) swap( arr[--more], arr[l] ); else l++; swap(arr[more], arr[r]); partion[0] = less + 1; partion[1] = more;&#125;/* * @Author wuhan * @Description * @Date * @Param 排序好[l,r]的位置, 比如[1,10]的位置 * @return **/void quickSort( vector&lt;int&gt;&amp; arr, int l, int r )&#123; if( l&lt;r )&#123; swap( arr[r], arr[l+ random() % (r -l +1)] ); int partion[2]; Partion(arr, l, r, partion); qucikSort( arr, l, partion[0] - 1 ); qucikSort( arr, partion[1] + 1, r ); &#125;&#125; 6. 堆排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/* * @Author wuhan * @Description 大根堆，任何一个子树的头部就是最大值;加入一个新节点，并且向上加的过程; 大根堆的插入过程中建立.复杂度O(n) * @Date * @Param * @return **/void HeapInsert( vector&lt;int&gt;&amp; arr, int index )&#123; while( arr[index] &gt; arr[(index - 1) / 2] )&#123; swap( arr[index], arr[(index - 1) / 2] ); index = (index - 1) / 2; &#125;&#125;/* * @Author wuhan * @Description 一个大根堆的某个index的值变小了，这个值往下降的过程 * @Date * @Param * @return **/void Heapify( vector&lt;int&gt; &amp;arr, int index, int heapSize )&#123; int left = 2*index + 1; while( left &lt; heapSize )&#123; // 找到左右孩子中的最大值； 只有右孩子存在, 且当右孩子&gt;左孩子，才把largest= left+1; 否则都是left ; int largest = left + 1 &lt; heapSize &amp;&amp; arr[left + 1] &gt; arr[left] ? left + 1 : left; // 找到左右孩子中的最大值与自己进行比较 largest = arr[largest] &gt; arr[index] ? largest : index; // 若发现最大的依然是我自己不就不动，直接返回 if( largest == index ) break; //执行到这里的时候,一定是largest != index; swap( arr[index], arr[largest] ); index = largest; left = 2*left + 1; &#125;&#125;void HeapSort( vector&lt;int&gt;&amp; arr )&#123; if( arr.size() ) return; int len = arr.size(); for( int i = 0; i&lt;len; ++i ) HeapInsert(arr, i); swap( arr[0], arr[--len] ); while( len &gt; 0 )&#123; Heapify( arr, 0, len ); swap( arr[0], arr[--len] ); &#125;&#125;]]></content>
  </entry>
</search>
